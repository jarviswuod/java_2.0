01 Intro

Database: Something that stores data 

Relational Database:

Entity: What we store data about: it can be a person, a customer, an order, a client, an employee
Attribute: What we store about a specific related data

We enter specific values for each attribute to make the relation between the attributes and the entity

Rows and Columns:
	Rows: are all attribute values for a specific entity, example: age, height, name, reg_no, address, username
	Column: are all values for a specific attribute type. Example: billy, 1234Pass, 38089372
	
Entity Type and Attribute Type:
	Entity Type is basically the category of the entities that we're storing
	Attribute Type: Are basically categories of attributes; example: username, name, password
	
	
02: Relational Database Management system:
Ability to run fancy queries to give specific results
Allows change in terms of data is presented (View mechanism)
	- Basically different users interacting with database based on their permissions, example admins vs normal user 
Consistency: maintain the frontend consistency
Allows to handle transaction: a transaction is a situation where we either do something either completely all the way or does not work at-all. Example: deducting money from account, adding money to a different account, updating the database, and saving, if something happens before all the events take place then the transaction is canceled and nothing is saved
Example:
	MySQL
	Oracle
	Sqlite
	
Difference between DBMS and rDBMS:



03: Introduction to SQL:
- Sql is a mediator between db and human English
- DB sections:
    - DDL -> Data Definition Language: Used to define database structure
                - CREATE
    - DML -> Data Manipulation Language: Manipulates data between db
                - UPDATE
                - JOIN
                - SELECT



04: What is Database Design:
Data integrity: Is a situation where all data is upto date and no repeating data
- Sections of a database design: More general to more specific
	- Conceptual schemas: How data is related example user and sales table
	- Logical schemas: Structuring out all our columns, our data types, our relationships and finally just make an assumption on security i.e no security flause
	- Physical schemas: What servr are we using, how are people going to access our data? actual programming of the database, build the webform, installing the server and testing, building the users who access the db, what different views we have, what data will be returned, we need to focus on security


Database design:
- This are skills that you know to build a database that is not having data integrity issues, update anomalies
- Is a method to separate information over multiple tables rather than having one huge table to store all information



05: Data Integrity:
- Is having correct data in our database i.e no repeating values, no incorrect values, no broken relationships between tables
- Entity integrity: Unique entities often implemented by different ids. id is used to enforce that is key, basically primary key
- Referential integrity: Foreign key
- Domain integrity: Range of what  values we are storing in a database example, data types, 10 digits, strings, boolean

Data types:
- integer
- text
- date
- 

06: Database terms:
- Data
- Database
- Relational Database
- DBMS
- rDBMS
- Null
- Anomalies
- Integrity
- Entity
- Referential
- Domain


- Entity
- Attributes/ Columns/ Field
- Relation/ Table/ File
- Tuple/ Rows/ Record/ Entry
- values
- DBdesign
- Schema
- Normalization
- Naming convention
- Keys



07: More Database terms:
- SQL
- DDL
- DML
- SQL keywords:
	- SELECT
- Frontend
- Backend
- Client side
- Server side
- Server side scripting Language
- views
- joins




08: Atomic values:
- Refers to the smallest values that can be stored in a database and makes sense


09: Relationships
- Multiple entities with multiple attibutes connected together
- Types of relationships
	- 1:1 -> One to one
	- 1:N -> One to many
	- M:N -> Many to Many

Intermediary table: A table that connects 2 separate tables in a many to many relationship



09: Introduction to Keys
	Rules of keys:
		- Unique
		- Never changing
		- Never null

	Primary Key Index:
		- 

	Foreign key:
		- Foreign key values can change while primary key values can never change

	Look up table:
		- 
- Super and Candidate keys
- Primary and foreign keys
- Primary and alternate keys
- Surrogate and Natural keys

- Super key is ANY number of columns that forces a row to be unique
- Candidate key is the LEAST number of columns needed to force every row to be unique
- Alternate keys are all the other canditate keys we did not choose as the primary key
- Surrogate and natural keys are categories of primary key
- Natural key is something that is naturally in the table and can be used as a primary key e.g username, email etc
- Surrogate keys are just column that's just added to your database to help identify a primary key e.g user_id, sale_id, comment_id



10: Foreign Keys
- Is a reference to primary key in a sparate table
- Primary keys are what sort each individual tables, while foreign keys are what connect tables and help protect integrity


NOT NULL Foreign Key
- NOT NULL -> Every single row must have a value
- If we require a relationship, we set it as not null it means that every foreign key value for that column is going to have a relationship
- Primary keys are required all the time, they are never changing and never null, foreign keys however are different as we can have them to where they're not required i.e they can be empty




11. Foreign key constraints:
	<-> parent		<-> child
	- ON DELETE		- RESTRICT(NO ACTION)
	- ON UPDATE		- CASCADE
				- SET NULL
				
12. Simple, Composite, Compound and keys:
	- Simple -> pk consists of one column
	- Composite -> pk consists of more than one column
	- Compound -> pk that has multiple columns & they're all keys themselves
	
13. Review and key points:
- Super key
- Candidate key
- Primary key
- Alternate key
- Foreign key


14. Introduction to Entity Relationship Modeling:
	EER - Enhanced Entity Relationship Model
	ERD - Enhanced Relationship Diagram
	ER Model - Entity Relationship Model


15. Cardinality:
- Is the relationship type between row of one table and row or rows of another table
 	one to one   |---------------|
 	one to many  |---------------<
 	many to one  <---------------|



16. Modality:
- Is weather or not a relationship is required

 	one to one   |--------------0-|
 	one to one   |--------------|-|  [NN- required]
 	one to many  |--------------0-<
 	one to many  <--------------|-<  [NN- required]


17. Introduction to Database Normalization
- Is the process of going through our database plan we have and start correcting things that might cause data integrity problems or repeating data
- Is a checklist that you have to follow to end up with a good design db

1 Normalization Form
2 Normalization Form
3 Normalization Form


18. First Normal Form of Database Normalization:
- Address -> Can be separated and broken down into columns
- emails -> Multiple emails in one email column
- duplicate data -> Same values for the column with only one email difference
- Only repeating foreign keys are allowed not entire rowss/ data



19. Second Normal Form of Database Normalization:
- Deals with partial dependency i.e when a column only depends on part of the primary key (there's a composite or compound key)
 - Example:
		- author -> author_id, fn, ln, birthdate
		- book_author -> book_id, author_id, author_position, * isbn
		- book -> book_id, isbn

	- ISBN doesnot make sense under book_author because it does only depend on book_id under book entity
	- author_position depends on both the book and the author entity

	- N/B: For the second normal form you have to be first in the first normal form and second remove all the dependecies by removing columns that depend on only one entity



20. Third Normal Form of Database Normalization:
- Deals with transitive dependency which is when a column depends on another column which depends on another column which depends on the primary key
- Example:
	- Review -> review_id, review, star, star_meaning, user_id

	- Explanation:
		-> In this case 'star_meaning' depends on 'star' and 'star' depends on 'review_id'. This is a bad design

	- Fix:
		-> To fix this you take the columns that take columns that are causing an issue and move them to a separate table and then create a foreign key to replace them in place of the actual column

	- NOTE:
		- The main idea of third normal form is to take transitive dependency and move them to a separate table then create a foreign key refer to that table


- Example:
	- Review -> review_id, review, star_id, user_id
	- Star -> star_id, star, star_meaning

- Summary:
	- First normal form is making everything atomic
	- Second normal form is removing any partial dependecies
	- Third normal form is removing any transitive dependecies



21: Clustered, Nonclustered and composite Indexes:
- Non Clustered Index - This means that the data is not actually where the index is index is a separate thing and it actually sorts the data and is basically a point that that tells you how to get to the data
	- Example:
		- In a book where you find the index at the back then it leads you towards a page where the word is located

- Clustered Index - Is like a phone book where it actually re-organizes the actual data in a way that is easy to use

- Non-clustered points to the data. Clustered organises the actual data
- We can have multiple non clustered indexes since it's basically a list of references that point to the actual data so you can organise it in different ways BUT for the clustered index you can only have one those because it actually organises the data that way example a phone book (it can't be listed A-Z and also by the size of the phone number sooohhh!!! its either sorted by name or sorted by phone number)



When working with database we use certain columns for certain things
When working with database we use index to help databases in making queries faster saving toones of resources because rather than having to scan through the whole database we go to a specific row range due to index 
The downside is not does the database have to update when we update it but also we have to update the indexes (example when changing content within a book; logically think of it)

In most cases the primary keys usually is cluster indexed and mostly preferred indexing over non-clustred indexing
NOTE:
	- Have indexes on columns you usually use
	- Indexes increase the speed joins

- Composite index: is index on 2 or more columns example first name and last name


22: Data types
	- date
		- date
		- time
		- datetime
		- timestamp

	- numeric
	- strings
		char - rigid
		varchar -  flexible



23: Introduction to Joins:
- Inner Join:
	- Takes 2 tables and  where there's connected rows from both tables it presents them in a new generated table   
	
	* SELECT fn, ln, amount_paid FROM customer INNER JOIN card ON customer.customer_id = card.customer_id


24: Inner join on 3 tables
-  Example:
	- User -> user_id, email, username, password
	- video -> video_id, title, description
	- comment -> comment_id, user_id, video_id, comment


	- JOINT TABLE -> username, title, comment

	- Syntax:
		SELECT username, title, comment 
		  FROM user 
		  INNER JOIN comment
		  ON user.user_id = comment.user_id
		  INNER JOIN video
		  ON video.video_id = comment.video_id



24: Outer joins
	Join condition
	customer.customer_id = card.customer_id

	- Inner join pushes away cards that has no customer and customers without any card combining only customers with cards and cards that are are having a customer
	- Outer join however combines the entire rows from one of the tables weather or not they have an associated entity on the other side


Types of outer join:
	- Left outer join
		- Left join allows for all rows on the left table and only associated rows from the right table

	- Right outer join
		- Right join allows for all rows on the right table and only associated rows from the left table

	- Full outer join
 
	- NOTE:
		-  Having the customer_id column set to NOT NULL under the card entity this means under the right outer join all the cards will have associated customers with them which might bring about some confusion
		- The whole point of having a right or left outer join is including all the rows of a specific entity weather their is a relationship between them or row i.e cards with customers and cards with customers or customers with cards and customers without cards, having a column set to NOT NULL brings the confusion worse


		- In practise most people don't use the right outer join, what they do instead is to flip the entity placement statements when they are making up their queries
			- Example:
				- SELECT fn, ln, email, card_number 
		  		  FROM card
		  		  LEFT JOIN customer
		  		  ON card.customer_id = customer.customer_id

					---------------- INSTEAD OF ----------------

				- SELECT fn, ln, email, card_number 
		  		  FROM customer
		  		  RIGHT JOIN card
		  		  ON customer.customer_id = card.customer_id


25: Join with NOT NULL Columns
26: Outer Join Across 3 Tables
- Example:
	- User -> user_id
	- Comment -> comment_id, user_id, video_id
	- Video -> video_id


		SELECT username, title, comment 
		  FROM user 
		  LEFT JOIN comment
		  ON user.user_id = comment.user_id
		  RIGHT JOIN video
		  ON video.video_id = comment.video_id


	- Explanation:
		- User && comment: All users & All comments
		- Video && Left Join result: All videos, All comments, some users



27: Aliases (AS)
- Alias refers to renaming something
- Entity alias example:
	 user AS customer

- Column alias example:
	SELECT email, first_name, last_name
	  FROM user

	---------------- TO ----------------

	SELECT email as contact, first_name as "first name", last_name as "last name"
	  FROM user



28: Self Joins
- It's basically duplicating the same table/entity we have and joining those 2 tables together
- Example a referral option in a website or business where discounts are given out
- Alias is important in playing a role on self join

- Example:
	- user -> user_id, pass, email, fn, ln, referred_by


	SELECT v1.fn, v1.ln, v1.email, v2.email
	  FROM user AS v1
	  JOIN user AS v2
	  ON v1.referred_by = v2.user_id

	---------------- OR ----------------

	SELECT v1.fn, v1.ln, v1.email, v2.email AS "Referred By"
	  FROM user AS v1
	  JOIN user AS v2
	  ON v1.referred_by = v2.user_id
